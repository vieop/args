#!/usr/bin/python

import sys
import os
import stat
#import rados
import json
import copy
import types
import subprocess
import socket
import json

"""
Something wrong with number of arguments
"""
class ArgumentError(Exception):
    pass

"""
Base class for all Ceph argument types

Instantiating an object sets any validation parameters 
(allowable strings, numeric ranges, etc.).  The 'valid'
method validates a string against that initialized instance,
throwing ArgumentError if there's a problem.
"""
class CephArgtype(object):
    def __init__(self, **kwargs):
        """
        set any per-instance validation parameters here 
        from kwargs (fixed string sets, integer ranges, etc)
        """
        pass

    def valid(self, s, partial=False):
        """
        run validation against given string s (generally one word);
        partial means to accept partial string matches (begins-with).
        if cool, return True
        if not, throw ArgumentError(msg-as-to-why)
        """
        pass

    def __repr__(self):
        """
        return string representation of description of type.  Note,
        this is not a representation of the actual value.  Subclasses
        probably also override __str__() to give a more user-friendly
        'name/type' description for use in command format help messages.
        """
        a = ''
        if hasattr(self, 'typeargs'):
            a = self.typeargs;
        s = ''
        return '{}(\'{}\')'.format(self.__class__.__name__, a)

    def __str__(self):
        """
        where __repr__ (ideally) returns a string that could be used to
        reproduce the object, __str__ returns one you'd like to see in
        print messages.  Use __str__ to format the argtype descriptor
        as it would be useful in a command usage message.
        """
        return '<{}>'.format(self.__class__.__name__)

"""
range-limited integers, [+|-][0-9]+ or 0x[0-9a-f]+
range: list of 1 or 2 ints, [min] or [min,max]
"""
class CephInt(CephArgtype):
    def __init__(self, range=''):
        if isinstance(range, types.StringType):
            if range == '':
                self.range = list()
            else:
                self.range = list(range.split('|'))
                self.range = map(int, self.range)
        else:
            self.range = range

    def valid(self, s, partial=False):
        try:
            val = long(s)
        except ValueError:
            raise ArgumentError("{} doesn't represent an int".format(s))
        if len(self.range) == 2:
            if val < self.range[0] or val > self.range[1]:
                raise ArgumentError("{} not in range {}".format(val, self.range))
        elif len(self.range) == 1:
            if val < self.range[0]:
                raise ArgumentError("{} not in range {}".format(val, self.range))
        return True

    def __str__(self):
        r = ''
        if len(self.range):
            r = '(range {} len {})'.format(self.range, len(self.range))
        return '<integer{}>'.format(r)


"""
range-limited float type
range: list of 1 or 2 floats, [min] or [min, max] """
class CephFloat(CephArgtype):
    def __init__(self, range=''):
        if isinstance(range, types.StringType):
            if range == '':
                self.range = list()
            else:
                self.range = list(range.split('|'))
                self.range = map(float, self.range)
        else:
            self.range = range

    def valid(self, s, partial=False):
        try:
            val = float(s)
        except ValueError:
            raise ArgumentError("{} doesn't represent a float".format(s))
        if len(self.range) == 2:
            if val < self.range[0] or val > self.range[1]:
                raise ArgumentError("{} not in range {}".format(val, self.range))
        elif len(self.range) == 1:
            if val < self.range[0]:
                raise ArgumentError("{} not in range {}".format(val, self.range))
        return True

    def __str__(self):
        r = ''
        if len(self.range):
            r = "(range {})".format(self.range)
        return '<float{}>'.format(r)

"""
String.  Not much use for this; maybe we might use illegal chars
for something?
"""
class CephString(CephArgtype):
    def __init__(self, badchars=''):
        self.badchars = badchars

    def valid(self, s, partial=False):
        for c in self.badchars:
            if c in s:
                raise ArgumentError("bad char {} in {}".format(c, s))
        return True

    def __str__(self):
        b = ''
        if len(self.badchars):
            b = '(without chars in {})'.format(self.badchars)
        return '<string{}>'.format(b)

"""
Admin socket path; check that it's readable and S_ISSOCK
"""
class CephSocketpath(CephArgtype):
    def valid(self, s, partial=False):
        mode = os.stat(s).st_mode
        if not stat.S_ISSOCK(mode):
            raise ArgumentError('socket path {} is not a FIFO'.format(s))
        return True
    def __str__(self):
        return '<admin-socket-path>'

"""
IP address (v4 or v6) with optional port
"""
class CephIPAddr(CephArgtype):
    def valid(self, s, partial=False):
        # parse off port, use socket to validate addr
        type = 6
        if s.startswith('['):
            type = 6
        elif s.find('.') != -1:
            type = 4
        if type == 4:
            port = s.find(':')
            if (port != -1):
                a = s[:port]
                p = s[port+1:]
                if int(p) > 65535:
                    raise ArgumentError('{}: invalid IPv4 port'.format(p))
            else:
                a = s
                p = None
            try:
                socket.inet_pton(socket.AF_INET, a)
            except:
                raise ArgumentError('{}: invalid IPv4 address'.format(a))
        else:
            # v6
            if s.startswith('['):
                end = s.find(']')
                if end == -1:
                    raise ArgumentError('{} missing terminating ]'.format(s))
                if s[end+1] == ':':
                    try:
                        p = int(s[end+2])
                    except:
                        raise ArgumentError('{}: bad port number'.format(s))
                a = s[1:end]
            else:
                a = s
                p = None
            try:
                socket.inet_pton(socket.AF_INET6, a)
            except:
                raise ArgumentError('{} not valid IPv6 address'.format(s))
        if p is not None and long(p) > 65535:
            raise ArgumentError("{} not a valid port number".format(p))
        return True

    def __str__(self):
        return '<IPaddr[:port]>' 

class CephEntityAddr(CephIPAddr):
    def valid(self,s):
        ip, nonce = s.split('/')
        if not super(CephIPAddr, self).valid(self, ip):
            raise ArgumentError('CephEntityAddr {}: ip address invalid'.format(s))
        return True

    def __str__(self):
        return '<EntityAddr>'

"""
Pool name; checked for presence in cluster
"""
class CephPoolname(CephArgtype):
    def valid(self, s):
        # if cluster.pool.exists(s):
        #    raise ValueError("pool {} does not exist".format(s))
        return True

    def __str__(self):
        return '<poolname>'

"""
Object name.  Maybe should be combined with Pool name as they're always
present in pairs, and then could be checked for presence
"""
class CephObjectname(CephArgtype):
    def valid(self, s, partial=False):
        return True

    def __str__(self):
        return '<objectname>'

"""
pgid, in form N.xxx (N = pool number, xxx = hex pgnum)
"""
class CephPgid(CephArgtype):
    def valid(self, s, partial=False):
        if s.find('.') == -1:
            raise ArgumentError('pgid has no .')
        poolid, pgnum = s.split('.')
        try:
            pgnum = int(pgnum, 16)
        except:
            raise ArgumentError('pgnum {} not hex integer'.format(pgnum))
        return True

    def __str__(self):
        return '<pgid (p.xxx)>'

"""
Name, or type.id, where type is osd|mon|client|mds, and id is a base10 int
"""
class CephName(CephArgtype):
    def valid(self, s, partial=False):
        if s.find('.') == -1:
            raise ArgumentError('no .')
        t, i = s.split('.')
        if not t in ('osd', 'mon', 'client', 'mds'):
            raise ArgumentError('unknown type ' + self.t)
        if t == 'osd':
            try:
                i = int(i)
            except:
                raise ArgumentError('osd id ' + i + ' not integer')
            # could check for valid id?
        return True

    def __str__(self):
        return '<name (type.id)>'

"""
Set of string literals; init with valid choices
"""

class CephChoices(CephArgtype):
    def __init__(self, strings='', **kwargs):
        self.strings=strings.split('|')

    def valid(self, s, partial=False):
        if not partial:
            if not s in self.strings:
                raise ArgumentError("{} not in {}".format(s, self.strings))
            return True

        # partial
        for t in self.strings:
            if t.beginswith(s):
                return True
        raise ArgumentError("{} not in {}".format(s, self.strings))

    def __str__(self):
        if len(self.strings) == 1:
            return '{}'.format(self.strings[0])
        else:
            return '<one of \'{}\'>'.format('|'.join(self.strings))

"""
Openable file
"""
class CephFilepath(CephArgtype):
    def valid(self, s, partial=False):
        try:
            open(s, 'a+')
        except Exception as e:
            raise ArgumentError('can\'t open {}: {}'.format(s, e))

    def __str__(self):
        return '<outfilename>'

"""
'Fragment' ??? XXX
"""
class CephFragment(CephArgtype):
    def valid(self, s, partial=False):
        if s.find('/') == -1:
            raise ArgumentError('{}: no /'.format(s))
        val, bits = s.split('/')
        # XXX is this right?
        if not val.startswith('0x'):
            raise ArgumentError("{} not a hex integer".format(val))
        try:
            long(val)
        except:
            raise ArgumentError('can\'t convert {} to integer'.format(val))
        try:
            long(bits)
        except:
            raise ArgumentError('can\'t convert {} to integer'.format(bits))
        return True

    def __str__(self):
        return "<CephFS fragment ID (0xvvv/bbb)>"


""" 
CephUUID: pretty self-explanatory
"""
class CephUUID(CephArgtype):
    def valid(self, s, partial=False):
        try:
            uuid.UUID(s)
        except Exception as e:
            raise ArgumentError('invalid UUID {}: {}'.format(s, e))
        return True

    def __str__(self):
        return '<uuid>'

############################################################################

# argdesc(typename, [type-specific kwargs], name='name', n=numallowed, req=False, **kwargs)
# validation rules:
# typename: type(**kwargs) will be constructed
# later, type.validate(w) will be called with a word in that position
# name is used for parse errors and for constructing JSON output
# n is a numeric literal or 'n|N', meaning "at least one, but maybe more"
# req=False means the argument need not be present in the list
# anything else are arguments to pass to the type constructor

class argdesc(object):
    def __init__(self, t, name='cmd', n=1, req=True, **kwargs):
        if isinstance(t, types.StringTypes):
            self.t = CephChoices
            self.typeargs = dict({'strings':t})
            self.req = True
        else:
            self.t = t
            self.typeargs = kwargs
            self.req = bool(req == True or req == 'True')

        self.name = name
        self.N = (n == 'N' or n == 'n')
        self.n = n
        if self.N:
            self.n = 1
        self.instance = self.t(**self.typeargs)

    def __repr__(self):
        r = 'argdesc(' + str(self.t) + ', '
        internals = ['n', 'typeargs', 'instance', 't']
        for (k,v) in self.__dict__.iteritems():
            if k.startswith('__') or k in internals:
                pass
            else:
                r += '{}={}, '.format(k,v)
        for (k,v) in self.typeargs.iteritems():
                r += '{}={}, '.format(k,v)
        return r[:-2] + ')'

    def __str__(self):
        #s = '{}({})'.format(self.name, str(self.instance))
        if self.t == CephChoices and len(self.instance.strings) == 1:
            s = '{}'.format(str(self.instance))
        else:
            s = '{}({})'.format(self.name, str(self.instance))
            if self.N:
                s += '[' + str(self.instance) + '...]'
        if not self.req:
            s = '{' + s + '}'
        return s

def concise_sig(sig):
    first = True
    s = ''
    for d in sig:
        if first:
            first = False
        else:
            s += ' '
        s += str(d)
    return s

"""
parse_json_funcsig(s)

A function signature is an array of argdesc; it can be represented 
in JSON as 
{'arg1':
  {
   'type': type, 'name': paramname, 'n': paramnum, req: True|False
   .

   .
   .
  }
  .
  .
}

Parse the string s and return a function signature (or thrown an
exception).
"""

def parse_json_funcsig(s):
    argnum = 0
    try:
        sig = json.loads(s)
    except Exception as e:
        print >> sys.stderr, "Couldn't parse JSON funcsig from {}: {}".format(s, e)
        raise e
    newsig = []
    for d in sig:
        argnum += 1
        if isinstance(d, types.StringTypes):
            t = d
            d = {'type':t, 'name':'arg{}'.format(argnum)}
        else:
            if not 'type' in d:
                raise TypeError('JSON descriptor{} has no type'.format(sig))
            # look up type string in our globals() dict; if it's an object
            # of type types.TypeType, it must be a locally-defined class.
            # otherwise, we haven't a clue.
            if d['type'] in globals():
                t = globals()[d['type']]
                if type(t) != types.TypeType: 
                    raise TypeError('unknown type {}'.format(d['type']))
            else:
                raise TypeError('no type found in {}'.format(d))
        kwargs = dict()
        for key, val in d.items():
            if key not in ['type', 'name', 'n', 'req']:
                kwargs[key] = val
        newsig.append(argdesc(t,
                              name=d.get('name', None),
                              n=d.get('n', 1),
                              req=d.get('req', True),
                              **kwargs))
    return newsig


def validate_one(word, desc, partial=False):
    # may raise exception
    desc.instance.valid(word, partial)
    desc.numseen += 1
    if desc.N:
        desc.n = desc.numseen + 1
    return True

"""
matchnum(s, signature, partial=False)

Returns number of arguments matched in s against signature.
Can be used to determine most-likely command for full or partial
matches (partial applies to string matches).
"""

def matchnum(s, signature, partial=False):
    mysig = copy.deepcopy(signature)
    words = s.split()
    matched = 0
    for desc in mysig:
        setattr(desc, 'numseen', 0)
        while desc.numseen < desc.n:
            try:
                word = words.pop(0)
            except:
                # out of input, all of rest better be not required
                if desc.req and not desc.N and desc.numseen < desc.n:
                    return matched
            # may raise exception
            try:
                validate_one(word, desc, partial)
            except Exception as e:
                return matched
        matched += 1
    return matched

"""
validate(s, signature)

Assumes s represents a possible command input following format of
signature.  Runs a validation; no exception means it's OK
"""

def validate(s, signature):
    mysig = copy.deepcopy(signature)
    words = s.split()
    argpos = 1
    d = dict()
    for desc in mysig:
        setattr(desc, 'numseen', 0)
        while desc.numseen < desc.n:
            try:
                word = words.pop(0)
            except:
                # out of input, all of rest better be not required
                if desc.req and not desc.N and desc.numseen < desc.n:
                    if (desc.n):
                        req = 'at least'
                    else:
                        req = 'exactly'
                    raise ArgumentError('saw {} of {}({}): expected {} {}'.format(desc.numseen, desc.name, desc, req, desc.n))
                else:
                    break
            # may raise exception
            validate_one(word, desc)
            if desc.name in d:
                d[desc.name] += ' ' + word
            else:
                d[desc.name] = word
        argpos += 1
    return json.dumps(d)

# convenience function

def try_validate(s, sig):
    try:
        dump = validate(s, sig)
        print'{!r} ok against {}'.format(s, sig)
        print dump
    except Exception as e:
        print'{!r} failed: {}'.format(s, e)
    print

def selftest():
    sig = [argdesc('osd'), argdesc('stat')]
    print sig
    for c in ['osd stat', 'osd foo']:
        try_validate(c, sig)
    sig = [argdesc('osd'), argdesc('find'),
           argdesc(CephInt, name='n', req=True)]
    for c in ['osd find s', 'osd find', 'osd find 1']:
        try_validate(c, sig)
    sig = [argdesc(CephInt, name='ids', req=True, n='N')]
    print sig
    try_validate('0 1 2' , sig)
    print sig
    try_validate('0 1 2 s' , sig)

    sig = parse_json_funcsig('{"signame":"mylittlesiggy", "sig":[{"type":"literal", "name":"arg1", "req":false}]}')
    try_validate('literal', sig)
    try_validate('iteral', sig)
    sig = parse_json_funcsig('{"signame":"mybigsiggy", "sig":[{"type":"CephInt", "name":"arg1", "req":false}]}')
    try_validate('1', sig)
    try_validate('', sig)
    try_validate('s', sig)

    sigs = [
        [argdesc('osd'), argdesc('crush'), argdesc('tunables'),
         argdesc(CephChoices,
                 strings='legacy|argonaut|bobtail|optimal|default')],
        [argdesc('mon'), argdesc('stat')],
        [argdesc('mon'), argdesc('getmap')],
        [argdesc('mon'), argdesc('dump')],
        [argdesc('mon'), argdesc('add'),
         argdesc(CephName, name="name", req=True), argdesc(CephAddr, name="addr", req=True)],
        [argdesc('mon'), argdesc('remove'), argdesc(CephName)]
    ]

    try_validate("osd crush tunables foo", sigs[0])
    try_validate("osd crush tunables legacy", sigs[0])
    try_validate("mon stat", sigs[1])
    try_validate("mon add mon.a 10.1.1.4", sigs[4])
    try_validate("mon add mon.a 10.1.1.4:1000", sigs[4])
    try_validate("mon add mon.a ffe0::0", sigs[4])
    try_validate("mon add mon.a [ffe0::0]:6789", sigs[4])

    intsig = [argdesc(CephInt, range=[0,15])]
    try_validate('-1', intsig)
    try_validate('0', intsig)
    try_validate('1', intsig)
    try_validate('15', intsig)
    try_validate('16', intsig)
    intsig = [argdesc(CephInt, range=[-128, 127])]
    try_validate('0', intsig)
    try_validate('-1', intsig)
    try_validate('-128', intsig)
    try_validate('-129', intsig)
    try_validate('127', intsig)
    try_validate('128', intsig)
    try_validate('255', intsig)
    try_validate('256', intsig)

    floatsig = [argdesc(CephFloat, range=[0.0, 1.0])]
    try_validate('1.0', floatsig)
    try_validate('1.000001', floatsig)
    try_validate('0.0', floatsig)
    try_validate('-0.0', floatsig)
    try_validate('-0.0000001', floatsig)

# this is what will be opened, with these args, to snarf a set of
# of command descriptors, one per line, each one parseable by 
# parse_json_funcsig into a signature.
COMMAND = './cmd'

def main():
    #global cluster
    #cluster = rados.Rados(conffile='')
    verbose = True

    # fetch JSON sigs from command
    p = subprocess.Popen('./cmd', stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    outdata, errdata = p.communicate()
    if (len(errdata)):
        print "error: ", errdata
        sys.exit(1)

    sigs = list()
    for a in outdata.split('\n'):
        if len(a.strip()) == 0:
            continue
        sig = parse_json_funcsig(a)
        sigs.append(sig)

        if verbose:
            print concise_sig(sig)

    # validate input args against list of sigs

    args = ' '.join(sys.argv[1:])
    if len(args) == 0:
        sys.exit(0)

    found = None
    max = 0
    bestsigs = []
    for sig in sigs:
        matched = matchnum(args, sig, partial=True)
        if (matched > max):
            if verbose:
                print "better match: {} > {}:{} ".format(matched, max, sig)
            max = matched
            bestsigs = [sig]
        elif matched == max:
            bestsigs.append(sig) 

    for sig in bestsigs:
        try:
            print validate(args, sig)
            found = sig
            break
        except Exception as e:
            if verbose:
                print >> sys.stderr, "almost {}:\n** {}".format(concise_sig(sig), e)
            pass

    if found is None:
        print '{}: invalid command'.format(args)
        sys.exit(1)

if __name__ == '__main__':
    main()
