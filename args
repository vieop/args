#!/usr/bin/python

import sys
import os
import stat
#import rados
import json
import copy
import types

class ArgumentError(Exception):
    pass

"""
Base class for all Ceph argument types
"""
class CephArgtype(object):
    def __init__(self, **kwargs):
        """
        set any per-instance validation parameters here 
        from kwargs (fixed string sets, integer ranges, etc)
        """
        pass
    def valid(self, s):
        """
        run validation against given string s (generally one word);
        if cool, return True
        if not, throw ValueError(msg-as-to-why)
        """
        pass
    def __repr__(self):
        a = ''
        if hasattr(self, 'typeargs'):
            a = self.typeargs;
        s = ''
        return '{}(\'{}\')'.format(self.__class__.__name__, a)

"""
range-limited integers, [+|-][0-9]+ or 0x[0-9a-f]+
range: list of 1 or 2 ints, [min] or [min,max]
"""
class CephInt(CephArgtype):
    def __init__(self, range=''):
        self.range = list(range.split('|'))

    def valid(self, s):
        try: 
            val = long(s)
        except:
            raise ValueError("{} doesn't represent an int".format(s))
        if len(self.range) == 2:
            if val < self.range[0] or val > self.range[1]:
                raise ValueError("{} not in range {}".format(val, self.range))
        elif len(self.range) == 1:
            if val < self.range[0]:
                raise ValueError("{} not in range {}".format(val, self.range))
        if val < 0:
            val = -val - 1
        return True

    def __str__(self):
        r = ''
        if len(self.range):
            r = self.range
        return '{}({})'.format(self.__class__.__name__, r)
	 

"""
range-limited float type
range: list of 1 or 2 floats, [min] or [min, max] """
class CephFloat(CephArgtype):
    def __init__(self, range=''):
        self.range = range.split('|')
        print 'self.range: ', self.range

    def valid(self, s):
        try:
            val = float(s)
        except:
            raise ValueError("{} doesn't represent a float".format(s))
        if len(self.range) == 2:
            if val < self.range[0] or val > self.range[1]:
                raise ValueError("{} not in range {}".format(val, self.range))
        elif len(self.range) == 1:
            if val < self.range[0]:
                raise ValueError("{} not in range {}".format(val, self.range))
        return True

    def __str__(self):
        r = ''
        if len(self.range):
            r = self.range
        return '{}({})'.format(self.__class__.__name__, r)

"""
String.  Not much use for this; maybe we might use illegal chars
for something?
"""
class CephString(CephArgtype):
    def __init__(self, badchars=''):
        self.badchars = badchars

    def valid(self, s):
        for c in badchars:
            if c in s:
                raise ValueError("bad char {} in {}".format(c, s))
        return True

    def __str__(self):
	b = ''
        if len(self.badchars):
            b = self.badchars
	s = '{}({})'.format(self.__class__.__name__, b)
        
"""
Admin socket path; validated for openability and S_ISFIFO
"""
class CephSocketpath(CephArgtype):
    def valid(self, s):
        try:
            open(s, "r")
        except:
            raise ValueError('socket path: {} can\'t be opened'.format(s))
        mode = os.stat(s).st_mode
        if not stat.S_ISFIFO(mode):
            raise ValueError('socket path {} is not a FIFO'.format(s))
        return True

"""
IP address (v4 or v6) with optional port
"""
class CephAddr(CephArgtype):
    def valid(self, s):
        # parse off port, use socket to validate addr
        import socket
        type = 6
        if s.startswith('['):
            type = 6
        elif s.find('.') != -1:
            type = 4
        if type == 4:
            port = s.find(':')
            if (port != -1):
                a = s[:port]
                p = s[port+1:]
                if int(p) > 65535:
                    raise ValueError('{}: invalid IPv4 port'.format(p))
            else:
                a = s
                p = None
            try:
                socket.inet_pton(socket.AF_INET, a)
            except:
                raise ValueError('{}: invalid IPv4 address'.format(a))
        else:
            # v6
            if s.startswith('['):
                end = s.find(']')
                if end == -1:
                    raise ValueError('{} missing terminating ]'.format(s))
                if s[end+1] == ':':
                    try:
                        p = int(s[end+2])
                    except:
                        raise ValueError('{}: bad port number'.format(s))
                a = s[1:end]
            else:
                a = s
                p = None
            try:
                socket.inet_pton(socket.AF_INET6, a)
            except:
                raise ValueError('{} not valid IPv6 address'.format(s))
        if p is not None and long(p) > 65535:
            raise ValueError("{} not a valid port number".format(p))
        return True

"""
Pool name; checked for presence in cluster
"""
class CephPoolname(CephArgtype):
    def valid(self, s):
        # if cluster.pool.exists(s):
        #    raise ValueError("pool {} does not exist".format(s))
        return True

"""
Object name.  Maybe should be combined with Pool name as they're always
present in pairs, and then could be checked for presence
"""
class CephObjectname(CephArgtype):
    def valid(self, s):
        return True

"""
pgid, in form N.xxx (N = pool number, xxx = hex pgnum)
"""
class CephPgid(CephArgtype):
    def valid(self, s):
        if s.find('.') == -1:
            raise ValueError('pgid has no .')
        poolid, pgnum = s.split('.')
        try:
            pgnum = int(pgnum, 16)
        except:
            raise ValueError('pgnum {} not hex integer'.format(pgnum))
        return True

"""
Name, or type.id, where type is osd|mon|client|mds, and id is a base10 int
"""
class CephName(CephArgtype):
    def valid(self, s):
        if s.find('.') == -1:
            raise ValueError('no .')
        t, i = s.split('.')
        if not t in ('osd', 'mon', 'client', 'mds'):
            raise ValueError('unknown type ' + self.t)
        if t == 'osd':
            try:
                i = int(i)
            except:
                raise ValueError('osd id ' + i + ' not integer')
            # could check for valid id?
        return True

"""
Set of string literals; init with valid choices
"""

class CephChoices(CephArgtype):
    def __init__(self, strings='', **kwargs):
        self.strings=strings.split('|')

    def valid(self, s):
        if not s in self.strings:
            raise ValueError("{} not in {}".format(s, self.strings))
        return True

    def __str__(self):
        if len(self.strings) == 1:
            return '\'{}\''.format(self.strings[0])
        else:
            return '{}({})'.format(self.__class__.__name__, '|'.join(self.strings))

"""
Openable file
"""
class CephFilepath(CephArgtype):
    def valid(self, s):
        try:
            open(s, 'a+')
        except Exception as e:
            raise ValueError('can\'t open {}: {}'.format(s, e))

"""
'Fragment' ??? XXX
"""
class CephFragment(CephArgtype):
   def valid(self, s):
        if s.find('/') == -1:
            raise ValueError('{}: no /'.format(s))      
        val, bits = s.split('/')
        # XXX is this right?
        if not val.startswith('0x'):
            raise ValueError("{} not a hex integer".format(val))
        try:
            long(val)
        except:
            raise ValueError('can\'t convert {} to integer'.format(val))
        try:
            long(bits)
        except:
            raise ValueError('can\'t convert {} to integer'.format(bits))
        return True

""" 
CephUUID: pretty self-explanatory
""" 
class CephUUID(CephArgtype):
    def valid(self, s):
        try:
            uuid.UUID(s)
        except Exception as e:
            raise ValueError('invalid UUID {}: {}'.format(s, e))
        return True

############################################################################

# argdesc(typename, [type-specific kwargs], name='name', n=numallowed, req=False, **kwargs)
# validation rules:
# typename: type(**kwargs) will be constructed
# later, type.validate(w) will be called with a word in that position
# name is used for parse errors and for constructing JSON output
# n is a numeric literal or 'n|N', meaning "at least one, but maybe more"
# req=False means the argument need not be present in the list
# anything else are arguments to pass to the type constructor

class argdesc(object):
    def __init__(self, t, name='cmd', n=1, req=True, **kwargs):
        if isinstance(t, types.StringTypes):
            self.t = CephChoices
            self.typeargs = dict({'strings':t})
            self.req = True
        else:
            self.t = t
            self.typeargs = kwargs
            self.req = req

        self.name = name
        self.N = (n == 'N' or n == 'n')
        self.n = n
        if self.N:
            self.n = 1
        self.instance = self.t(**self.typeargs)

    def __repr__(self):
        r = 'argdesc(' + str(self.t) + ', '
        internals = ['n', 'typeargs', 'instance', 't']
        for (k,v) in self.__dict__.iteritems():
            if k.startswith('__') or k in internals:
                pass
            else:
                r += '{}={}, '.format(k,v)
        for (k,v) in self.typeargs.iteritems():
                r += '{}={}, '.format(k,v)
        return r[:-2] + ')'

    def __str__(self):
        if not self.req:
            s = '{' + str(self.instance) + '}'
        else:
            s = str(self.instance)
        return s

"""
parse_json_funcsig(s)

A function signature is an array of argdesc; it can be represented 
in JSON as 
{'arg1':
  {
   'type': type, 'name': paramname, 'n': paramnum, req: True|False
   .

   .
   .
  }
  .
  .
}

Parse the string s and return a function signature (or thrown an
exception).
"""

def parse_json_funcsig(s):
    import json
    argnum = 0
    try:
        sig = json.loads(s)
    except Exception as e:
        print >> sys.stderr, "Couldn't parse JSON funcsig from {}: {}".format(s, e)
        raise e
    newsig = []
    for d in sig:
        argnum += 1
        if isinstance(d, types.StringTypes):
            t = d
            d = {'type':t, 'name':'arg{}'.format(argnum)}
        else:
            if not 'type' in d:
                raise TypeError('JSON descriptor{} has no type'.format(sig))
            # look up type string in our globals() dict; if it's an object
            # of type types.TypeType, it must be a locally-defined class.
            # otherwise, we haven't a clue.
            if d['type'] in globals():
                t = globals()[d['type']]
                if type(t) != types.TypeType: 
                    raise TypeError('unknown type {}'.format(d['type']))
            else:
                raise TypeError('no type found in {}'.format(d))
        kwargs = dict()
        for key, val in d.items():
            if key not in ['type', 'name', 'n', 'req']:
                kwargs[key] = val
        newsig.append(argdesc(t,
                              name=d.get('name', None),
                              n=d.get('n', 1),
                              req=d.get('req', True),
                              **kwargs))
    return newsig


def validate_one(word, desc, argpos):
    # may raise exception
    desc.instance.valid(word)
    desc.numseen += 1
    if desc.N:
        desc.n = desc.numseen + 1
    return True

"""
validate(s,signature)

Assumes s represents a possible command input following format of
signature.  Runs a validation; no exception means it's OK
"""

def validate(s, signature):
    mysig = copy.deepcopy(signature)
    words = s.split()
    argpos = 1
    d = dict()
    for desc in mysig:
        setattr(desc, 'numseen', 0)
        while desc.numseen < desc.n:
            try:
                word = words.pop(0)
            except:
                # out of input, all of rest better be not required
                if desc.req and not desc.N and desc.n < desc.num:
                    if (desc.n):
                        req = 'at least'
                    else:
                        req = 'exactly'
                    raise ArgumentError('saw {} of param[{}]({}): expected {} {}'.format(desc.numseen, argpos, desc, req, desc.n))
                else:
                    break
            # may raise exception
            validate_one(word, desc, argpos)
            if desc.name in d:
                d[desc.name] += ' ' + word
            else:
                d[desc.name] = word
        argpos += 1
    return json.dumps(d)

# convenience function

def try_validate(s, sig):
    try:
        dump = validate(s, sig)
        print'{!r} ok against {}'.format(s, sig)
        print dump
    except Exception as e:
        print'{!r} failed: {}'.format(s, e)
    print

def selftest():
    sig = [argdesc('osd'), argdesc('stat')]
    print sig
    for c in ['osd stat', 'osd foo']:
        try_validate(c, sig)
    sig = [argdesc('osd'), argdesc('find'),
           argdesc(CephInt, name='n', req=True)]
    for c in ['osd find s', 'osd find', 'osd find 1']:
        try_validate(c, sig)
    sig = [argdesc(CephInt, name='ids', req=True, n='N')]
    print sig
    try_validate('0 1 2' , sig)
    print sig
    try_validate('0 1 2 s' , sig)

    sig = parse_json_funcsig('{"signame":"mylittlesiggy", "sig":[{"type":"literal", "name":"arg1", "req":false}]}')
    try_validate('literal', sig)
    try_validate('iteral', sig)
    sig = parse_json_funcsig('{"signame":"mybigsiggy", "sig":[{"type":"CephInt", "name":"arg1", "req":false}]}')
    try_validate('1', sig)
    try_validate('', sig)
    try_validate('s', sig)

    sigs = [
	[argdesc('osd'), argdesc('crush'), argdesc('tunables'),
	 argdesc(CephChoices,
		 strings='legacy|argonaut|bobtail|optimal|default')],
	[argdesc('mon'), argdesc('stat')],
	[argdesc('mon'), argdesc('getmap')],
	[argdesc('mon'), argdesc('dump')],
	[argdesc('mon'), argdesc('add'),
	 argdesc(CephName, name="name", req=True), argdesc(CephAddr, name="addr", req=True)],
	[argdesc('mon'), argdesc('remove'), argdesc(CephName)]
    ]

    try_validate("osd crush tunables foo", sigs[0])
    try_validate("osd crush tunables legacy", sigs[0])
    try_validate("mon stat", sigs[1])
    try_validate("mon add mon.a 10.1.1.4", sigs[4])
    try_validate("mon add mon.a 10.1.1.4:1000", sigs[4])
    try_validate("mon add mon.a ffe0::0", sigs[4])
    try_validate("mon add mon.a [ffe0::0]:6789", sigs[4])

    intsig = [argdesc(CephInt, range=[0,15])]
    try_validate('-1', intsig)
    try_validate('0', intsig)
    try_validate('1', intsig)
    try_validate('15', intsig)
    try_validate('16', intsig)
    intsig = [argdesc(CephInt, range=[-128, 127])]
    try_validate('0', intsig)
    try_validate('-1', intsig)
    try_validate('-128', intsig)
    try_validate('-129', intsig)
    try_validate('127', intsig)
    try_validate('128', intsig)
    try_validate('255', intsig)
    try_validate('256', intsig)

    floatsig = [argdesc(CephFloat, range=[0.0, 1.0])]
    try_validate('1.0', floatsig)
    try_validate('1.000001', floatsig)
    try_validate('0.0', floatsig)
    try_validate('-0.0', floatsig)
    try_validate('-0.0000001', floatsig)

def main():
    #global cluster
    #cluster = rados.Rados(conffile='')
    for a in sys.argv[1:]:
	sig = parse_json_funcsig(a)

	print '[',
	for d in sig:
	    print str(d),
        print "]"

if __name__ == '__main__':
    main()
